<html lang="en">
  <head>
    <title>Documentation - Smarkets Streaming API</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="style.css" />
  </head>
  <body>

    <div id="toc">
      <h1><a href="">Smarkets Streaming API Documentation</a></h1>
      <ul>
        <li><strong>{{ version }}</strong></li>
        <li><a href="">Introduction</a></li>
        <li><a href="#encode">Encoding Payloads</a>
          <ul>
            <li><a href="#encode-erlang">Erlang</a></li>
            <li><a href="#encode-python">Python</a></li>
            <li><a href="#encode-other">Other Languages</a></li>
          </ul>
        </li>
        <li><a href="#framing">Framing &amp; Sending</a></li>
        <li><a href="#code">Downloads &amp; Code</a></li>
        <li>
          <a href="#defs">Type Definitions</a>
          <ul>
          {% for name in order %}
          <li><a href="#{{ name }}">{{ name }}</a></li>
          {% endfor %}
          </ul>
        </li>
      </ul>
    </div>

    <div id="content">
      <h2 class="first">Introduction</h2>
      <!--p>
      </p-->
      <p>
      To work with the Smarkets Streaming API you will need to:
      <ol class="steps">
        <li>
        Create a persistent TCP connection to <code>api-dev.corp.smarkets.com:3701</code>
        </li>
        <li>
        <a href="#encode">Encode</a>, <a href="#framing" class="type">frame</a>, and send a <a href="#sequenced" class="type">sequenced</a> <a href="#payload" class="type">payload</a> with a <a href="#login" class="type">login</a> <a href="#message" class="type">message</a> to obtain a <a href="#session" class="type">session</a>.
        </li>
        <li>
        Receive the resulting <a href="#login-response" class="type">login-response</a> sent to you from Smarkets. You now have an API <a href="#session" class="type">session</a>.
        </li>
        <li>
        Send, receive, and respond to other <a href="#payloads">payloads</a> with specific <a href="#messages" class="type">messages</a> while maintaining and logging incoming and outgoing <a href="#seq" class="type">seq</a> numbers of <a href="#sequenced" class="type">sequenced</a> <a href="#payloads">payloads</a> for your <a href="#session" class="type">session</a>.
        </li>
        <li>
        All <a href="#sequenced" class="type">sequenced</a> <a href="#payloads">payloads</a> should be processed in sequence and should never be processed out of order, except for <a href="#replay" class="type">replay</a> and resuming <a href="#login-response" class="type">login-responses</a> which can be handled immediately.
        </li>
        <li>
        If your application disconnects or gets disconnected - resume the <a href="#session" class="type">session</a> by reconnecting and issuing a <a href="#sequenced" class="type">sequenced</a> <a href="#payload" class="type">payload</a> with the resuming <a href="#seq" class="type">seq</a> numbers and a <a href="#login" class="type">login</a> message with the <span class="field">session</span> field set.
        </li>
        <li>
        If a <a href="#sequenced" class="type">sequenced</a> <a href="#payload" class="type">payload</a> is received with a <a href="#seq" class="type">seq</a> greater than is expected a <a href="#replay" class="type">replay</a> message should be issued re-requesting the missing batch of messages.
        </li>
      </ol>
      </p>

      <h2 id="encode">Encoding Payloads</h2>
      <p>
      All <a href="#payload">payloads</a> are encoded into bytes compatible with <a href="http://code.google.com/p/protobuf/">Protocol Buffers</a> before being <a href="#framing">framed</a> and sent. How you do this will depend on the language you're using to communicate with Smarkets' servers. Here are some examples:
      </p>
      
      <h3 id="encode-erlang">Erlang</h3>
      <p>
      The type-spec for the Smarkets API is written in <a href="http://piqi.org/">Piqi</a>, so is easily compiled down into a whole bunch of Erlang records for you to use. Piqi also supports generating Protocol Buffers bytes with the generated code from piqic. Here's what using that looks like:
      </p>
<code class="block"><pre>
-spec login(binary(), binary()) -> iolist().
login(Username, Password) ->
  Payload = #seto_sequenced{
    seq = 1,
    message =
      {login, #seto_login{
          username = Username,
          password = Password
      }}
  },
  seto_piqi:gen_payload({sequenced, Payload}).</pre></code>
      <p>
      Head to the <a href="#code">Downloads & Code</a> section to grab the Erlang SDK
      </p>
      
      <h3 id="encode-python">Python</h3>
      <p>
      Since the type-spec for the Smarkets API is written in <a href="http://piqi.org/">Piqi</a>, we can translate this into a .proto file and easily get some python <a href="http://code.google.com/p/protobuf/">Protocol Buffers</a> code up and running. Here's how to use it:
      </p>
<code class="block"><pre>
def login(username, password):
    payload = seto_pb2.payload()
    payload.sequenced.seq = 1
    payload.sequenced.message.login.username = username
    payload.sequenced.message.login.password = password
    return payload.SerializeToString()</pre></code>
      <p>
      Head to the <a href="#code">Downloads & Code</a> section to grab the Python SDK
      </p>

      <h3 id="encode-other">Other Languages</h3>
      <p>
      As mentioned in the Erlang and Python examples above, Smarkets' API type definitions are described using <a href="http://piqi.org/">Piqi</a>. With this we can generate a <a href="http://code.google.com/p/protobuf/">Protocol Buffers</a> .proto definition which can then be used to generate code in <a href="http://protobuf.googlecode.com/">Java</a>, <a href="http://protobuf.googlecode.com/">C++</a>, and a <a href="http://code.google.com/p/protobuf/wiki/ThirdPartyAddOns">large list of other languages</a>.
      </p>
      <p>
      Head to the <a href="#code">Downloads & Code</a> section to grab the .piqi and .proto files
      </p>

      <h2 id="framing">Framing</h2>
      <p>

      </p>

      <h2 id="code">Downloads &amp; Code</h2>
      <p>
      To get started with the Smarkets API you'll need to grab the re-built SDKs, but if one isn't available for the language you want to use then you'll need to grab the <em>smk_api_common</em> distribution and use the <a href="http://code.google.com/p/protobuf/">Protocol Buffers</a> .proto definition to generate code for you.
      </p>
      {% if not live_site %}
      <p>
      Head to <a href="http://api.smarkets.com/docs/#code">http://api.smarkets.com/docs/#code</a> to grab the latest builds.
      </p>
      {% else %}
      <ul>
        <li>
          Prebuilt SDKs
          <ul>
            <li>Erlang - <a href="https://github.com/smarkets/smk_erlang_sdk/zipball/smk_erlang_sdk-{{ version }}.tar.gz">smk_erlang_sdk-{{ version }}.tar.gz</a></li>
            <li>Python - <a href="https://github.com/smarkets/smk_python_sdk/zipball/smk_python_sdk-{{ version }}.tar.gz">smk_python_sdk-{{ version }}.tar.gz</a></li>
            <li>.piqi and .proto specifications - <a href="https://github.com/smarkets/smk_api_common/zipball/smk_api_common-{{ version }}.tar.gz">smk_api_common-{{ version }}.tar.gz</a></li>
          </ul>
        </li>
        <li>Just these docs (also included in the SDKs above) - <a href="https://github.com/smarkets/smk_api_docs/zipball/smk_api_docs-{{ version }}.tar.gz">smk_api_docs-{{ version }}.tar.gz</a></li>
        <li><a href="https://github.com/smarkets/">Smarkets GitHub Account</a></li>
      </ul>
      {% endif %}

      <h2 id="defs">Type Definitions</h2>
      {% for pdef in piqdef %}
      {% with def=pdef.def %}
      {% if not def.name %}
      {% comment %}
      <div><strong>Error:</strong> {{ pdef }}</div>
      {% endcomment %}

      {% else %}
      <div class="def">
        <h3 id="{{ def.name }}">
          <span class="name">{{ def.name }}</span>
          <span class="piqi_type">{{ pdef.piqi_type }}</span>
          {% if pdef.piqi_type=="list" or pdef.piqi_type=="alias" %}
          {% type name=def.type.name %}
          {% endif %}
        </h4>

        {% ifequal pdef.piqi_type "record" %}
        <ul>
          {% for field in def.field %}
          <li>
          <span class="name">{% firstof field.name field.type.name %}</span>
          {% type name=field.type.name %}
          {% if field.default %}
          <span class="default">Default: {{ field.default.value }}</span>
          {% endif %}
          </li>
          {% endfor %}
        </ul>
        {% endifequal %}

        {% if pdef.piqi_type == "variant" or pdef.piqi_type == "enum"  %}
        <ul>
          {% for option in def.option %}
          <li>
          <span class="name">{% firstof option.name option.type.name %}</span>
          {% if option.type %}
          {% type name=option.type.name %}
          {% endif %}
          </li>
          {% endfor %}
        </ul>
        {% endif%}

        {% if pdef.description %}
        <div class="description">{{ pdef.description }}</div>
        {% endif %}

      </div>
      {% endif %}
      {% endwith %}
      {% endfor %}
    </div>

    </body>
  </html>
